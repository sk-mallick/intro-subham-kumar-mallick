<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Scroll-Driven Timeline</title>
    <!-- Google Fonts: Poppins -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles */
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #030712; /* A slightly darker gray for depth */
        }
        
        /* This container is fixed to the viewport, holding all visual elements */
        #fixed-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* Allows scrolling events to pass through to the body */
        }

        /* Odometer styles */
        .digit-container {
            position: relative;
            display: inline-flex;
            width: 0.6em;
            height: 1em;
            overflow: hidden;
            justify-content: center;
        }

        .digit-container span {
            position: absolute;
            text-align: center;
            width: 100%;
            transition: transform 0.5s cubic-bezier(0.65, 0, 0.35, 1);
        }

        /* Typing cursor effect */
        @keyframes blink {
            50% { background-color: transparent; }
        }
        .typing-cursor::after {
            content: '';
            display: inline-block;
            width: 0.1em;
            height: 0.8em;
            background-color: #ef4444; /* red-500 */
            margin-left: 0.1em;
            animation: blink 0.8s step-end infinite;
            vertical-align: bottom;
        }
        
        @keyframes node-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        
        .network-node {
            position: absolute;
            transform-origin: center center;
            transition: transform 0.4s ease, filter 0.3s;
            pointer-events: auto; /* Re-enable pointer events for nodes to be interactive */
        }

        .network-node:hover {
            transform: translateY(-4px) scale(1.05);
            filter: brightness(1.1);
        }

        .node-float {
            animation: node-float 4s ease-in-out infinite;
        }

        /* Tooltip pointer */
        #node-tooltip::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 10px;
            height: 10px;
            background-color: #1f2937; /* bg-gray-800 */
            border-right: 1px solid #374151; /* border-gray-700 */
            border-bottom: 1px solid #374151;
        }

        /* Progress dots styling */
        .progress-dot {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .progress-dot:hover {
            transform: scale(1.75) !important; /* Ensure hover effect is prioritized */
            background-color: #f87171 !important; /* red-400 */
        }
    </style>
</head>
<body>
    
    <!-- This fixed container holds all the visual elements that stay on screen -->
    <div id="fixed-container">
        <!-- Background: gradient overlay + dot grid -->
        <div class="absolute inset-0 bg-gradient-to-br from-gray-900 via-black to-gray-800"></div>
        <div class="absolute inset-0 opacity-10" style="background-image: radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.1) 1px, transparent 0); background-size: 20px 20px;"></div>

        <!-- Main Content Area -->
        <div id="main-content" class="relative z-10 text-center w-full max-w-6xl mx-auto flex justify-center">
            <div id="timeline-anchor" class="relative h-[500px] w-[700px] flex justify-center items-center">
                <!-- Layer 1: SVG Connector Lines -->
                <div id="network-lines-container" class="w-full h-full absolute top-0 left-0 z-0 transition-opacity duration-300"></div>
                <!-- Layer 2: Odometer Year Display -->
                <div id="odometer-year" class="text-9xl md:text-[10rem] font-bold flex items-center justify-center transition-colors duration-500 text-white absolute z-10 bg-black/40 rounded-lg backdrop-blur-sm px-4 py-2">
                    <span class="static-digits">20</span>
                    <div id="decade-container" class="digit-container"><span>0</span></div>
                    <div id="unit-container" class="digit-container"><span>4</span></div>
                </div>
                <!-- Layer 3: Nodes, Text, and other content -->
                <div id="content-container" class="w-full h-full absolute top-0 left-0 z-20 transition-opacity duration-300"></div>
                <!-- Layer 4: Tooltip for nodes -->
                <div id="node-tooltip" class="absolute w-64 bg-gray-800 border border-gray-700/50 rounded-lg p-3 shadow-xl text-left hidden opacity-0 transition-opacity duration-300 z-30"></div>
            </div>
        </div>
        
        <!-- UI Elements that need to be clickable -->
        <div id="progress-dots" class="fixed bottom-8 left-1/2 transform -translate-x-1/2 flex items-center space-x-3 z-20 pointer-events-auto"></div>
        <div class="fixed bottom-8 right-8 z-20 pointer-events-auto">
             <button id="restart-button" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-full font-medium transition-all duration-300 hover:scale-105 active:scale-95 shadow-lg hover:shadow-xl">‚Üª Restart</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- DATA (with updated text) ---
            const timelineEvents = [
                 { year: 2004, type: "network", mainText: "The Genesis: My Story Begins", nodes: [
                    { id: 1, title: "Born", description: "Born in the vibrant town of Koraput, Odisha.", color: "#EF4444", icon: "üë∂" },
                    { id: 2, title: "Hometown", description: "Koraput, a place of serene hills and valleys, was my first home.", color: "#10B981", icon: "üèûÔ∏è" },
                    { id: 3, title: "Family", description: "My journey started with the love and support of my family.", color: "#3B82F6", icon: "üë®‚Äçüë©‚Äçüëß" },
                ]},
                { year: 2008, text: "My learning journey began at Kendriya Vidyalaya No. 4   ", type: "simple"},
                { year: 2011, text: "Built strong foundations through middle schooling   ", type: "simple"},
                { year: 2020, text: "Designed & launched my first Personal Portfolio Website   ", type: "simple"},
                { year: 2021, text: "Completed Class X (CBSE) with 87.4%", type: "simple   "},
                { year: 2023, text: "Completed Class XII with 70.6% & Built a Shoe Billing System (Python + MySQL)"   , type: "simple"},
                { year: 2024, type: "network", mainText: "A Year of Exponential Growth", nodes: [
                    { id: 1, title: "B.Tech Started", description: "Began B.Tech in Computer Science at Trident Academy of Technology.", color: "#3B82F6", icon: "üéì" },
                    { id: 2, title: "Web Developer", description: "Worked as a Developer for Purvaansh Preschool & ACM Student Chapter.", color: "#10B981", icon: "üíª" },
                    { id: 3, title: "Hackathon Club", description: "Joined the Hackathon Club and contributed to innovation projects.", color: "#8B5CF6", icon: "üöÄ" },
                    { id: 4, title: "SIH Finalist", description: "Became a Smart India Hackathon Finalist, showcasing innovative solutions.", color: "#F59E0B", icon: "üèÜ" },
                    { id: 5, title: "IEEE Hackathon", description: "Active participant in IEEE Hackathon competitions.", color: "#EF4444", icon: "‚ö°" },
                    { id: 6, title: "Trithon Hackathon", description: "Developed a Carbon Offset App at the Trithon Hackathon.", color: "#06B6D4", icon: "üå±" }
                ]},
                { year: 2027, text: "Will graduate as a Computer Science Engineer.", isExpected: true, type: "simple" },
            ];

            // --- DOM ELEMENTS ---
            const odometerYearEl = document.getElementById('odometer-year');
            const decadeContainer = document.getElementById('decade-container');
            const unitContainer = document.getElementById('unit-container');
            const contentContainer = document.getElementById('content-container');
            const networkLinesContainer = document.getElementById('network-lines-container');
            const progressDotsContainer = document.getElementById('progress-dots');
            const restartButton = document.getElementById('restart-button');
            const nodeTooltip = document.getElementById('node-tooltip');
            const timelineAnchor = document.getElementById('timeline-anchor');

            // --- STATE & CONFIG ---
            let currentDisplayYear = 0;
            let currentEventIndex = -1;
            let lastRenderedEventIndex = -1;
            
            const EVENT_SCROLL_DURATION = 1800; 
            const TRAVEL_SCROLL_DURATION = 1000;
            let sectionMarkers = []; 

            // --- CORE SCROLL LOGIC ---

            /**
             * Easing function to make scroll animations feel more natural (slow start, fast middle, slow end).
             */
            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            function calculateScrollMarkers() {
                sectionMarkers = [];
                let currentScrollPos = 0;
                timelineEvents.forEach((_, index) => {
                    sectionMarkers.push({ type: 'event', index, start: currentScrollPos, end: currentScrollPos + EVENT_SCROLL_DURATION });
                    currentScrollPos += EVENT_SCROLL_DURATION;
                    if (index < timelineEvents.length - 1) {
                        sectionMarkers.push({ type: 'travel', index, start: currentScrollPos, end: currentScrollPos + TRAVEL_SCROLL_DURATION });
                        currentScrollPos += TRAVEL_SCROLL_DURATION;
                    }
                });
                document.body.style.height = `${currentScrollPos}px`;
            }

            function onScroll() {
                const scrollY = window.scrollY;
                const currentSection = sectionMarkers.find(m => scrollY >= m.start && scrollY <= m.end);
                
                if (!currentSection) {
                    if (scrollY < sectionMarkers[0]?.start) {
                        updateTimeline(sectionMarkers[0], 0);
                    } else {
                        const lastEvent = sectionMarkers.filter(s => s.type === 'event').pop();
                        updateTimeline(lastEvent, 1);
                    }
                    return;
                }

                const sectionProgress = (scrollY - currentSection.start) / (currentSection.end - currentSection.start);
                const easedProgress = easeInOutCubic(sectionProgress); // Apply easing to the progress
                updateTimeline(currentSection, easedProgress); // Use the eased progress for all animations
            }

            function updateTimeline(section, progress) {
                const eventIdx = section.type === 'event' ? section.index : (progress < 0.5 ? section.index : section.index + 1);
                if (eventIdx !== currentEventIndex) {
                    currentEventIndex = eventIdx;
                    renderProgressDots();
                }

                if (section.type === 'travel') {
                    contentContainer.style.opacity = 0;
                    networkLinesContainer.style.opacity = 0;
                    const fromEvent = timelineEvents[section.index];
                    const toEvent = timelineEvents[section.index + 1];
                    const year = Math.round(fromEvent.year + (toEvent.year - fromEvent.year) * progress);
                    updateOdometer(year, false);
                } else if (section.type === 'event') {
                    const event = timelineEvents[section.index];
                    updateOdometer(event.year, true);
                    
                    if (section.index !== lastRenderedEventIndex) {
                        prepareEventContent(event);
                        lastRenderedEventIndex = section.index;
                    }
                    
                    contentContainer.style.opacity = 1;
                    networkLinesContainer.style.opacity = 1;

                    if (event.type === 'simple') {
                        updateTypingAnimation(event.text, progress);
                    } else if (event.type === 'network') {
                        updateNetworkAnimation(event, progress);
                    }
                }
            }
            
            // --- ANIMATION SCRUBBING FUNCTIONS ---

            function updateTypingAnimation(text, progress) {
                const p = contentContainer.querySelector('p');
                if (!p) return;
                const charCount = Math.floor(text.length * progress);
                p.textContent = text.substring(0, charCount);
                p.classList.toggle('typing-cursor', progress < 0.99 && progress > 0.01);
            }

            function updateNetworkAnimation(event, progress) {
                const titleP = contentContainer.querySelector('.text-container p');
                if(titleP) {
                    const titleProgress = Math.min(1, progress * 4); 
                    const charCount = Math.floor(event.mainText.length * titleProgress);
                    titleP.textContent = event.mainText.substring(0, charCount);
                    titleP.classList.toggle('typing-cursor', titleProgress < 0.99 && titleProgress > 0.01);
                }

                const lineProgressStart = 0.25;
                const numNodes = event.nodes.length;
                const progressPerLine = (1 - lineProgressStart) / numNodes;

                event.nodes.forEach((node, index) => {
                    const path = document.getElementById(`mask-path-${node.id}`);
                    const nodeEl = document.getElementById(`node-${node.id}`);
                    if (!path || !nodeEl) return;

                    const lineStart = lineProgressStart + (index * progressPerLine);
                    let currentLineProgress = 0;
                    if (progress >= lineStart) {
                        currentLineProgress = Math.min(1, (progress - lineStart) / progressPerLine);
                    }

                    const length = parseFloat(path.dataset.length);
                    path.style.strokeDashoffset = `${length * (1 - currentLineProgress)}`;
                    nodeEl.style.opacity = currentLineProgress > 0.8 ? '1' : '0';
                });
            }

            // --- PREPARATION & RENDERING FUNCTIONS ---
            
            function prepareEventContent(event) {
                contentContainer.innerHTML = '';
                networkLinesContainer.innerHTML = '';
                if (event.type === 'simple') {
                    contentContainer.innerHTML = `<div class="text-container absolute top-1/2 left-1/2 -translate-x-1/2 translate-y-32 w-full max-w-2xl px-4"><p class="text-red-500 text-xl md:text-2xl font-semibold"></p></div>`;
                } else if (event.type === 'network') {
                    networkLinesContainer.innerHTML = `<svg id="connector-svg" class="absolute inset-0 w-full h-full"></svg>`;
                    contentContainer.innerHTML = `<div class="text-container absolute top-1/2 left-1/2 -translate-x-1/2 translate-y-32 w-full max-w-2xl px-4"><p class="text-red-400 text-xl md:text-2xl font-semibold"></p></div>`;

                    const nodePositions = getNodePositions(event.nodes.length);
                    event.nodes.forEach((node) => {
                        const nodeEl = document.createElement('div');
                        nodeEl.id = `node-${node.id}`;
                        contentContainer.appendChild(nodeEl);
                    });
                    
                    redrawNetworkLines(event); 
                }
            }
            
            function getNodePositions(count) {
                 return {
                    3: [{ top: '20%', left: '7%' }, { top: '45%', left: '95%' }, { top: '11%', left: '69%' }],
                    6: [{ top: '35%', left: '0%' }, { top: '17%', left: '90%' }, { top: '6%', left: '10%' }, { top: '96%', left: '79%' }, { top: '85%', left: '10%' }, { top: '5%', left: '50%' }]
                }[count] || [];
            }
            
            function generateCustomPath2004(start, end, nodeIndex) {
                 if (nodeIndex === 0 || nodeIndex === 1) return `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;
                 if (nodeIndex === 2) return `M ${start.x} ${start.y} V ${end.y} H ${end.x}`;
                 return `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
            }

            function redrawNetworkLines(event) {
                const svgEl = document.getElementById('connector-svg');
                if (!svgEl) return;
                svgEl.innerHTML = '';
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                svgEl.appendChild(defs);

                const anchorBox = timelineAnchor.getBoundingClientRect();
                const yearBox = odometerYearEl.getBoundingClientRect();
                
                let startPoints;
                if (event.year === 2004) {
                     startPoints = [
                        { x: yearBox.left - anchorBox.left, y: yearBox.top - anchorBox.top + yearBox.height/2 },
                        { x: yearBox.right - anchorBox.left, y: yearBox.top - anchorBox.top + yearBox.height/2 },
                        { x: yearBox.left - anchorBox.left + yearBox.width/2, y: yearBox.top - anchorBox.top },
                    ];
                } else {
                     startPoints = [
                        { x: yearBox.left - anchorBox.left, y: yearBox.top - anchorBox.top + yearBox.height/2 }, { x: yearBox.right - anchorBox.left, y: yearBox.top - anchorBox.top + yearBox.height/2 },
                        { x: yearBox.left - anchorBox.left + yearBox.width/2, y: yearBox.top - anchorBox.top }, { x: yearBox.left - anchorBox.left + yearBox.width/2, y: yearBox.bottom - anchorBox.top },
                        { x: yearBox.left - anchorBox.left, y: yearBox.bottom - anchorBox.top}, { x: yearBox.right - anchorBox.left, y: yearBox.bottom - anchorBox.top},
                    ];
                }
                
                const nodePositions = getNodePositions(event.nodes.length);
                event.nodes.forEach((node, index) => {
                    const pos = nodePositions[index];
                    const nodeEl = document.getElementById(`node-${node.id}`);
                    nodeEl.className = "network-node node-float flex flex-col items-center text-center w-24 opacity-0 transition-opacity duration-300";
                    let transformStyle = 'translate(-50%, -50%)';
                    if (pos.left === '0%') transformStyle = 'translate(0, -50%)';
                    else if (pos.left === '100%') transformStyle = 'translate(-100%, -50%)';
                    nodeEl.style.cssText = `left: ${pos.left}; top: ${pos.top}; transform: ${transformStyle};`;
                    nodeEl.innerHTML = `<div class="icon-wrapper w-12 h-12 rounded-full flex items-center justify-center text-white text-3xl shadow-lg mb-2" style="background-color: ${node.color};">${node.icon}</div><span class="text-sm font-medium text-gray-300">${node.title}</span>`;
                    nodeEl.addEventListener('mouseenter', (e) => showTooltip(e, node));
                    nodeEl.addEventListener('mouseleave', hideTooltip);

                    const iconEl = nodeEl.querySelector('.icon-wrapper');
                    const iconRect = iconEl.getBoundingClientRect();
                    const end = { x: iconRect.left + iconRect.width/2 - anchorBox.left, y: iconRect.top + iconRect.height/2 - anchorBox.top };
                    const start = startPoints[index % startPoints.length];
                    const pathData = (event.year === 2004) ? generateCustomPath2004(start, end, index) : `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;

                    const uniqueId = `mask-${node.id}`;
                    const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
                    mask.id = uniqueId;
                    
                    const maskPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    maskPath.id = `mask-path-${node.id}`;
                    maskPath.setAttribute('d', pathData);
                    maskPath.setAttribute('stroke', 'white');
                    maskPath.setAttribute('stroke-width', '5');
                    maskPath.setAttribute('fill', 'none');
                    maskPath.setAttribute('stroke-linecap', 'round');
                    
                    const length = maskPath.getTotalLength();
                    maskPath.dataset.length = length;
                    maskPath.style.strokeDasharray = length;
                    maskPath.style.strokeDashoffset = length;
                    mask.appendChild(maskPath);
                    defs.appendChild(mask);

                    const visiblePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    visiblePath.setAttribute('d', pathData);
                    visiblePath.setAttribute('stroke', node.color);
                    visiblePath.setAttribute('stroke-width', '2');
                    visiblePath.setAttribute('fill', 'none');
                    visiblePath.setAttribute('stroke-linecap', 'round');
                    visiblePath.setAttribute('stroke-dasharray', '8 4');
                    visiblePath.setAttribute('mask', `url(#${uniqueId})`);
                    svgEl.appendChild(visiblePath);
                });
            }

            // --- UTILITY & UI FUNCTIONS ---

            function updateOdometer(year, isEventYear) {
                const isCorrectColor = odometerYearEl.classList.contains(isEventYear ? 'text-white' : 'text-gray-500');
                if (year === currentDisplayYear && isCorrectColor) return;
            
                odometerYearEl.classList.toggle('text-white', isEventYear);
                odometerYearEl.classList.toggle('text-gray-500', !isEventYear);
                
                if (year !== currentDisplayYear) {
                    const yearStr = year.toString();
                    const decade = yearStr[2];
                    const unit = yearStr[3];

                    // Animate only for event years, otherwise just update text for smooth scrolling
                    if (isEventYear) {
                        animateDigit(decadeContainer, decade);
                        animateDigit(unitContainer, unit);
                    } else {
                        decadeContainer.innerHTML = `<span>${decade}</span>`;
                        unitContainer.innerHTML = `<span>${unit}</span>`;
                    }
                }
                currentDisplayYear = year;
            }

            function animateDigit(container, newDigit) {
                const currentSpan = container.querySelector('span');
                if (currentSpan && currentSpan.textContent === newDigit) return;
                
                const newSpan = document.createElement('span');
                newSpan.textContent = newDigit;
                newSpan.style.transform = 'translateY(100%)';
                
                // Clear old spans before adding new one to prevent overlap
                container.innerHTML = ''; 
                container.appendChild(newSpan);

                if (currentSpan) {
                     const oldSpan = currentSpan.cloneNode(true);
                     oldSpan.style.transform = 'translateY(0%)';
                     container.insertBefore(oldSpan, newSpan);
                     requestAnimationFrame(() => {
                         oldSpan.style.transform = 'translateY(-100%)';
                         setTimeout(() => oldSpan.remove(), 500);
                     });
                }

                requestAnimationFrame(() => {
                    newSpan.style.transform = 'translateY(0%)';
                });
            }
            
            function renderProgressDots() {
                progressDotsContainer.innerHTML = timelineEvents.map((_, index) => 
                    `<div class="progress-dot w-2 h-2 rounded-full" data-index="${index}" style="background-color: ${index === currentEventIndex ? '#ef4444' : (index < currentEventIndex ? '#f87171' : '#6b7280')}; transform: ${index === currentEventIndex ? 'scale(1.5)' : 'scale(1)'};"></div>`
                ).join('');
                document.querySelectorAll('.progress-dot').forEach(dot => {
                    dot.addEventListener('click', () => {
                        const targetIndex = parseInt(dot.dataset.index);
                        const targetSection = sectionMarkers.find(m => m.type === 'event' && m.index === targetIndex);
                        if (targetSection) {
                            window.scrollTo({ top: targetSection.start + 1, behavior: 'smooth' });
                        }
                    });
                });
            }

            function showTooltip(e, node) {
                 const rect = e.currentTarget.getBoundingClientRect();
                 const anchorRect = timelineAnchor.getBoundingClientRect();
                 nodeTooltip.innerHTML = `<div class="flex items-center mb-2"><div class="w-8 h-8 rounded-full flex items-center justify-center text-white text-xl mr-2" style="background-color: ${node.color};">${node.icon}</div><h3 class="font-semibold text-white">${node.title}</h3></div><p class="text-gray-300 text-sm leading-relaxed">${node.description}</p>`;
                 const leftPos = rect.left - anchorRect.left + (rect.width / 2);
                 const topPos = rect.top - anchorRect.top;
                 nodeTooltip.style.left = `${leftPos}px`;
                 nodeTooltip.style.top = `${topPos}px`;
                 nodeTooltip.style.transform = 'translate(-50%, calc(-100% - 12px))';
                 nodeTooltip.classList.remove('hidden');
                 setTimeout(() => nodeTooltip.classList.remove('opacity-0'), 10);
            }

            function hideTooltip() {
                nodeTooltip.classList.add('opacity-0');
                setTimeout(() => { if (nodeTooltip.classList.contains('opacity-0')) nodeTooltip.classList.add('hidden'); }, 300);
            }

            // --- INITIALIZATION ---
            function init() {
                calculateScrollMarkers();
                window.addEventListener('scroll', onScroll, { passive: true });
                window.addEventListener('resize', () => {
                    calculateScrollMarkers();
                    // Redraw current event's static elements on resize
                    if(currentEventIndex >=0) {
                        const event = timelineEvents[currentEventIndex];
                        if (event.type === 'network') {
                            redrawNetworkLines(event);
                        }
                    }
                    onScroll();
                });
                restartButton.addEventListener('click', () => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
                onScroll(); 
            }

            init();
        });
    </script>
    
    <script>
        // Disable right-click and developer tools
        document.addEventListener("contextmenu", e => e.preventDefault());
        document.onkeydown = function(e) {
            if (e.keyCode == 123 || (e.ctrlKey && e.shiftKey && ['I','J','C'].includes(e.key.toUpperCase())) ) {
                return false;
            }
        }
        
        // Disable text selection and copying
        document.addEventListener('selectstart', e => e.preventDefault());
        document.addEventListener('dragstart', e => e.preventDefault());
        
        // Disable copy, cut, paste, select all
        document.addEventListener('keydown', function(e) {
            // Disable Ctrl+A (Select All)
            if (e.ctrlKey && e.keyCode === 65) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+C (Copy)
            if (e.ctrlKey && e.keyCode === 67) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+X (Cut)
            if (e.ctrlKey && e.keyCode === 88) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+V (Paste)
            if (e.ctrlKey && e.keyCode === 86) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+S (Save)
            if (e.ctrlKey && e.keyCode === 83) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+P (Print)
            if (e.ctrlKey && e.keyCode === 80) {
                e.preventDefault();
                return false;
            }
        });
        
        // Disable text selection via CSS
        document.addEventListener('DOMContentLoaded', function() {
            const style = document.createElement('style');
            style.textContent = `
                * {
                    -webkit-user-select: none !important;
                    -moz-user-select: none !important;
                    -ms-user-select: none !important;
                    user-select: none !important;
                    -webkit-touch-callout: none !important;
                    -webkit-tap-highlight-color: transparent !important;
                }
            `;
            document.head.appendChild(style);
        });
    </script>
</body>
</html>


