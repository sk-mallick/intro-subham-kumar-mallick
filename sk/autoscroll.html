<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Animated Timeline</title>
    <!-- Google Fonts: Poppins -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles */
        body {
            font-family: 'Poppins', sans-serif;
        }
        
        /* Odometer styles */
        .digit-container {
            position: relative;
            display: inline-flex;
            width: 0.6em;
            height: 1em;
            overflow: hidden;
            justify-content: center;
        }

        .digit-container span {
            position: absolute;
            text-align: center;
            width: 100%;
            transition: transform 0.5s cubic-bezier(0.65, 0, 0.35, 1);
        }

        /* Typing cursor effect */
        @keyframes blink {
            50% { background-color: transparent; }
        }
        .typing-cursor::after {
            content: '';
            display: inline-block;
            width: 0.1em;
            height: 0.8em;
            background-color: #ef4444; /* red-500 */
            margin-left: 0.1em;
            animation: blink 0.8s step-end infinite;
            vertical-align: bottom;
        }
        
        @keyframes node-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        
        .network-node {
            position: absolute;
            transform-origin: center center;
            transition: transform 0.4s ease, opacity 0.5s ease-out, filter 0.3s;
        }

        .network-node:hover {
            transform: translateY(-4px) scale(1.05);
            filter: brightness(1.1);
        }

        .node-float {
            animation: node-float 4s ease-in-out infinite;
        }
        
        @keyframes endpoint-pulse {
            0% { r: 3; opacity: 1; }
            100% { r: 15; opacity: 0; }
        }
        .line-endpoint {
            animation: endpoint-pulse 0.8s ease-out forwards;
        }
        
        /* Tooltip pointer */
        #node-tooltip::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 10px;
            height: 10px;
            background-color: #1f2937; /* bg-gray-800 */
            border-right: 1px solid #374151; /* border-gray-700 */
            border-bottom: 1px solid #374151;
        }

        /* Clickable progress dots - Fixed glitches */
        .progress-dot {
            cursor: pointer;
            transition: all 0.3s ease;
            will-change: transform, background-color;
            backface-visibility: hidden;
            transform: translateZ(0);
        }
        .progress-dot:hover {
            transform: scale(1.75) translateZ(0);
            background-color: #f87171 !important; /* red-400 */
        }
        .progress-dot:active {
            transform: scale(1.5) translateZ(0);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col justify-center items-center h-screen p-4 overflow-hidden relative">
    
    <!-- Background: gradient overlay + dot grid -->
    <div class="absolute inset-0 bg-gradient-to-br from-gray-900 via-black to-gray-800"></div>
    <div class="absolute inset-0 opacity-10" style="background-image: radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.1) 1px, transparent 0); background-size: 20px 20px; background-attachment: fixed;"></div>

    <!-- Main Content -->
    <div id="main-content" class="relative z-10 text-center w-full max-w-6xl mx-auto flex justify-center">
        <div id="timeline-anchor" class="relative h-[500px] w-[700px] flex justify-center items-center">
            
            <!-- Layer 1: Container for connector lines (behind the year) -->
            <div id="network-lines-container" class="w-full h-full absolute top-0 left-0 pointer-events-none z-0"></div>

            <!-- Layer 2: Odometer Year Display with integrated shield -->
            <div id="odometer-year" class="text-9xl md:text-[10rem] font-bold flex items-center justify-center transition-all duration-700 text-gray-200 absolute z-10 bg-black/40 rounded-lg backdrop-blur-sm px-4 py-2">
                <span class="static-digits">20</span>
                <div id="decade-container" class="digit-container"><span>0</span></div>
                <div id="unit-container" class="digit-container"><span>4</span></div>
            </div>

            <!-- Layer 3: Content Container for nodes and text (in front of the year) -->
            <div id="content-container" class="w-full h-full absolute top-0 left-0 pointer-events-none z-20">
                <!-- Content will be injected here -->
            </div>

            <!-- Layer 4: Tooltip (Highest Z-index) -->
            <div id="node-tooltip" class="absolute w-64 bg-gray-800 border border-gray-700/50 rounded-lg p-3 shadow-xl text-left hidden opacity-0 transition-opacity duration-300 z-30 pointer-events-none">
                <!-- Tooltip content injected here -->
            </div>
        </div>
    </div>
    
    <!-- Progress Dots -->
    <div id="progress-dots" class="fixed bottom-8 left-1/2 transform -translate-x-1/2 flex items-center space-x-3 z-20">
        <!-- Dots will be injected here -->
    </div>

    <!-- Buttons -->
    <button id="skip-button" class="fixed bottom-8 right-8 text-gray-400 hover:text-white transition-all duration-300 text-sm font-mono z-20 hover:scale-105 active:scale-95">SKIP â†’</button>
    <button id="restart-button" class="fixed bottom-8 right-8 bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-full font-medium transition-all duration-300 z-20 hidden hover:scale-105 active:scale-95 shadow-lg hover:shadow-xl">â†» Restart</button>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- DATA ---
            const timelineEvents = [
                { year: 2004, type: "network", mainText: "The Genesis: My Story Begins", nodes: [
                    { id: 1, title: "Born", description: "Born in the vibrant town of Koraput, Odisha.", color: "#EF4444", icon: "ðŸ‘¶" },
                    { id: 2, title: "Hometown", description: "Koraput, a place of serene hills and valleys, was my first home.", color: "#10B981", icon: "ðŸžï¸" },
                    { id: 3, title: "Family", description: "My journey started with the love and support of my family.", color: "#3B82F6", icon: "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§" },
                ]},
                { year: 2008, text: "My learning journey began at Kendriya Vidyalaya No. 4", type: "simple"},
                { year: 2011, text: "Built strong foundations through middle schooling", type: "simple"},
                { year: 2020, text: "Designed & launched my first Personal Portfolio Website", type: "simple"},
                { year: 2021, text: "Completed Class X (CBSE) with 87.4%", type: "simple"},
                { year: 2023, text: "Completed Class XII with 70.6% & Built a Shoe Billing System (Python + MySQL)", type: "simple"},
                { year: 2024, type: "network", mainText: "A Year of Exponential Growth", nodes: [
                    { id: 1, title: "B.Tech Started", description: "Began B.Tech in Computer Science at Trident Academy of Technology.", color: "#3B82F6", icon: "ðŸŽ“" },
                    { id: 2, title: "Web Developer", description: "Worked as a Developer for Purvaansh Preschool & ACM Student Chapter.", color: "#10B981", icon: "ðŸ’»" },
                    { id: 3, title: "Hackathon Club", description: "Joined the Hackathon Club and contributed to innovation projects.", color: "#8B5CF6", icon: "ðŸš€" },
                    { id: 4, title: "SIH Finalist", description: "Became a Smart India Hackathon Finalist, showcasing innovative solutions.", color: "#F59E0B", icon: "ðŸ†" },
                    { id: 5, title: "IEEE Hackathon", description: "Active participant in IEEE Hackathon competitions.", color: "#EF4444", icon: "âš¡" },
                    { id: 6, title: "Trithon Hackathon", description: "Developed a Carbon Offset App at the Trithon Hackathon.", color: "#06B6D4", icon: "ðŸŒ±" }
                ]},
                { year: 2027, text: "Will be graduating as a Computer Science Engineer", isExpected: true, type: "simple" },
            ];

            // --- STATE ---
            let currentEventIndex = 0;
            let currentDisplayYear = timelineEvents[0].year;
            let isAnimating = false;
            let resizeTimeout;
            let autoAdvanceTimeout;
            let animationSessionId = null; 

            // --- DOM ELEMENTS ---
            const odometerYearEl = document.getElementById('odometer-year');
            const decadeContainer = document.getElementById('decade-container');
            const unitContainer = document.getElementById('unit-container');
            const contentContainer = document.getElementById('content-container');
            const networkLinesContainer = document.getElementById('network-lines-container');
            const progressDotsContainer = document.getElementById('progress-dots');
            const skipButton = document.getElementById('skip-button');
            const restartButton = document.getElementById('restart-button');
            const nodeTooltip = document.getElementById('node-tooltip');
            const timelineAnchor = document.getElementById('timeline-anchor');

            // --- RENDER & ANIMATION FUNCTIONS ---
            function animateDigit(container, newDigit) {
                const currentSpans = Array.from(container.querySelectorAll('span'));
                const lastDigit = currentSpans.length > 0 ? currentSpans[currentSpans.length - 1].textContent : null;
                if (lastDigit === newDigit) return;
                const newSpan = document.createElement('span');
                newSpan.textContent = newDigit;
                newSpan.style.transform = 'translateY(100%)';
                container.appendChild(newSpan);
                requestAnimationFrame(() => {
                    newSpan.style.transform = 'translateY(0%)';
                    currentSpans.forEach(span => {
                        span.style.transform = 'translateY(-100%)';
                        setTimeout(() => span.remove(), 500);
                    });
                });
            }

            function setOdometer(year, isEventYear) {
                const yearStr = year.toString();
                const decade = yearStr[2];
                const unit = yearStr[3];
                animateDigit(decadeContainer, decade);
                animateDigit(unitContainer, unit);
                odometerYearEl.classList.toggle('text-gray-200', isEventYear);
                odometerYearEl.classList.toggle('text-gray-600', !isEventYear);
                currentDisplayYear = year;
            }
            
            function typeTextEffect(wrapper, text, className, onComplete) {
                let i = 0;
                const p = document.createElement('p');
                p.className = `${className} typing-cursor`;
                wrapper.innerHTML = '';
                wrapper.appendChild(p);
                setTimeout(() => wrapper.classList.remove('opacity-0'), 100);
                function typeChar() {
                    if (i < text.length) {
                        p.textContent += text.charAt(i);
                        i++;
                        setTimeout(typeChar, 40);
                    } else {
                        p.classList.remove('typing-cursor');
                        if (onComplete) onComplete();
                    }
                }
                setTimeout(typeChar, 300);
            }
            
            function renderTypingText(text, onComplete) {
                contentContainer.innerHTML = `<div class="text-container absolute top-1/2 left-1/2 -translate-x-1/2 translate-y-32 w-full max-w-2xl px-4 opacity-0 transition-opacity duration-500"></div>`;
                const wrapper = contentContainer.firstElementChild;
                const className = "text-red-500 text-xl md:text-2xl font-semibold";
                typeTextEffect(wrapper, text, className, () => {
                     autoAdvanceTimeout = setTimeout(onComplete, 2200);
                });
            }

            function renderNetworkView(event, onComplete) {
                contentContainer.innerHTML = '';
                networkLinesContainer.innerHTML = `<svg id="connector-svg" class="absolute inset-0 w-full h-full"><defs></defs></svg>`;
                const titleContainer = document.createElement('div');
                titleContainer.className = 'text-container absolute top-1/2 left-1/2 -translate-x-1/2 translate-y-32 w-full max-w-2xl px-4 opacity-0 transition-opacity duration-500';
                contentContainer.appendChild(titleContainer);
                const className = "text-red-400 text-xl md:text-2xl font-semibold";
                typeTextEffect(titleContainer, event.mainText, className, null);
                const nodePositions = {
                    3: [{ top: '20%', left: '7%' }, { top: '45%', left: '95%' }, { top: '11%', left: '69%' }],
                    6: [{ top: '35%', left: '0%' }, { top: '17%', left: '90%' }, { top: '0%', left: '10%' }, { top: '96%', left: '79%' }, { top: '85%', left: '10%' }, { top: '5%', left: '50%' }]
                }[event.nodes.length] || [];
                event.nodes.forEach((node, index) => {
                    const pos = nodePositions[index];
                    const nodeEl = document.createElement('div');
                    nodeEl.id = `node-${node.id}`;
                    nodeEl.className = "network-node node-float flex flex-col items-center text-center cursor-pointer pointer-events-auto w-24 opacity-0";
                    let transformStyle = 'translate(-50%, -50%)';
                    if (pos.left === '0%') transformStyle = 'translate(0, -50%)';
                    else if (pos.left === '100%') transformStyle = 'translate(-100%, -50%)';
                    nodeEl.style.cssText = `left: ${pos.left}; top: ${pos.top}; transform: ${transformStyle};`;
                    nodeEl.innerHTML = `<div class="icon-wrapper w-12 h-12 rounded-full flex items-center justify-center text-white text-3xl shadow-lg mb-2" style="background-color: ${node.color};">${node.icon}</div><span class="text-sm font-medium text-gray-300">${node.title}</span>`;
                    contentContainer.appendChild(nodeEl);
                    nodeEl.addEventListener('mouseenter', (e) => showTooltip(e, node));
                    nodeEl.addEventListener('mouseleave', hideTooltip);
                });
                setTimeout(() => redrawNetworkLines(event, true), 800);
                const totalDuration = 1000 + (event.nodes.length * 150) + 2000 + 4000;
                autoAdvanceTimeout = setTimeout(onComplete, totalDuration);
            }

            function generateHVPath(start, end) {
                const cornerRadius = 20;
                const signX = Math.sign(end.x - start.x) || 1;
                const signY = Math.sign(end.y - start.y) || 1;
                if (Math.abs(end.x - start.x) < cornerRadius * 2 || Math.abs(end.y - start.y) < cornerRadius * 2) {
                    return `M ${start.x} ${start.y} L ${end.x} ${start.y} L ${end.x} ${end.y}`;
                }
                if (Math.abs(end.x - start.x) > Math.abs(end.y - start.y)) {
                    const sweepFlag = signX * signY > 0 ? 0 : 1;
                    return `M ${start.x} ${start.y} H ${end.x - cornerRadius * signX} A ${cornerRadius} ${cornerRadius} 0 0 ${sweepFlag} ${end.x} ${start.y + cornerRadius * signY} V ${end.y}`;
                } else {
                    const sweepFlag = signX * signY > 0 ? 1 : 0;
                    return `M ${start.x} ${start.y} V ${end.y - cornerRadius * signY} A ${cornerRadius} ${cornerRadius} 0 0 ${sweepFlag} ${start.x + cornerRadius * signX} ${end.y} H ${end.x}`;
                }
            }
            
            // CUSTOM PATH GENERATION FOR 2004 - Sharp corners, perfect center connection!
            function generateCustomPath2004(start, end, nodeIndex) {
                
                // Node 1 (Born) - Left side: Sharp L-shape connecting to center
                if (nodeIndex === 0) {
                    return `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;
                }
                
                // Node 2 (Hometown) - Right side: Sharp L-shape connecting to center
                if (nodeIndex === 1) {
                    return `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;
                }
                
                // Node 3 (Family) - Top: Sharp L-shape connecting to center
                if (nodeIndex === 2) {
                    return `M ${start.x} ${start.y} V ${end.y} H ${end.x}`;
                }
                
                // Default fallback - straight line to center
                return `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
            }
            
            // CUSTOM PATH GENERATION FOR 2024 - Sharp corners, no curves!
            function generateCustomPath2024(start, end, nodeIndex) {
                
                // Node 1 (B.Tech Started) - Left side: Sharp L-shape
                if (nodeIndex === 0) {
                    return `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;
                }
                
                // Node 2 (Web Developer) - Right side: Sharp L-shape
                if (nodeIndex === 1) {
                    return `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;
                }
                
                // Node 3 (Hackathon Club) - Left side: Sharp L-shape
                if (nodeIndex === 2) {
                    return `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;
                }
                
                // Node 4 (SIH Finalist) - Right side: Sharp L-shape
                if (nodeIndex === 3) {
                    return `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;
                }
                
                // Node 5 (IEEE Hackathon) - Left side: Sharp L-shape
                if (nodeIndex === 4) {
                    return `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;
                }
                
                // Node 6 (Trithon Hackathon) - Right side: Sharp L-shape
                if (nodeIndex === 5) {
                    return `M ${start.x} ${start.y} H ${end.x} V ${end.y}`;
                }
                
                // Default fallback - straight line to center
                return `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
            }
            
            function redrawNetworkLines(event, isAnimated = false) {
                const svgEl = document.getElementById('connector-svg');
                if (!svgEl) return;
                svgEl.innerHTML = '<defs></defs>';
                const anchorBox = timelineAnchor.getBoundingClientRect();
                const yearBox = odometerYearEl.getBoundingClientRect();
                
                // CUSTOM START POINTS FOR 2004 EVENT
                let startPoints;
                if (event.year === 2004) {
                    // Custom start points for 2004 - you can modify these!
                    startPoints = [
                        { x: yearBox.left - anchorBox.left, y: yearBox.top - anchorBox.top + yearBox.height/2 }, // Left
                        { x: yearBox.right - anchorBox.left, y: yearBox.top - anchorBox.top + yearBox.height/2 }, // Right
                        { x: yearBox.left - anchorBox.left + yearBox.width/2, y: yearBox.top - anchorBox.top }, // Top
                    ];
                } else {
                    // Default start points for other events
                    startPoints = [
                        { x: yearBox.left - anchorBox.left, y: yearBox.top - anchorBox.top + yearBox.height/2 },
                        { x: yearBox.right - anchorBox.left, y: yearBox.top - anchorBox.top + yearBox.height/2 },
                        { x: yearBox.left - anchorBox.left + yearBox.width/2, y: yearBox.top - anchorBox.top },
                        { x: yearBox.left - anchorBox.left + yearBox.width/2, y: yearBox.bottom - anchorBox.top },
                    ];
                }
                
                event.nodes.forEach((node, index) => {
                    const nodeEl = document.getElementById(`node-${node.id}`);
                    if (!nodeEl) return;
                    const iconEl = nodeEl.querySelector('.icon-wrapper');
                    const iconRect = iconEl.getBoundingClientRect();
                    const iconRadius = iconRect.width / 2;
                    const end = {
                        x: iconRect.left + iconRadius - anchorBox.left,
                        y: iconRect.top + iconRadius - anchorBox.top,
                    };
                    const start = startPoints[index % startPoints.length];
                    
                    // Connect lines directly to the center of nodes for better appearance
                    let adjustedEnd = { ...end };
                    // No adjustment needed - lines connect to exact center
                    
                    // CUSTOM LINE GENERATION FOR 2004 AND 2024
                    let pathData;
                    if (event.year === 2004) {
                        pathData = generateCustomPath2004(start, adjustedEnd, index);
                    } else if (event.year === 2024) {
                        pathData = generateCustomPath2024(start, adjustedEnd, index);
                    } else {
                        pathData = generateHVPath(start, adjustedEnd);
                    }
                    
                    const delay = isAnimated ? index * 0.15 : 0;
                    createLine(svgEl, pathData, node.color, delay, node.id, isAnimated, adjustedEnd);
                });
            }

            function createLine(svg, pathData, strokeColor, delay, nodeId, isAnimated, endCoords) {
                const animationDuration = 2000;
                const defs = svg.querySelector('defs');
                const uniqueId = `${nodeId}-${Math.random().toString(36).substr(2, 9)}`;
                const visiblePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                visiblePath.setAttribute('d', pathData);
                visiblePath.setAttribute('stroke', strokeColor);
                visiblePath.setAttribute('stroke-width', '2');
                visiblePath.setAttribute('fill', 'none');
                visiblePath.setAttribute('stroke-linecap', 'round');
                visiblePath.setAttribute('stroke-dasharray', '8 4');
                
                if (isAnimated) {
                    const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
                    const maskId = `mask-${uniqueId}`;
                    mask.id = maskId;
                    const maskPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    maskPath.setAttribute('d', pathData);
                    maskPath.setAttribute('fill', 'none');
                    maskPath.setAttribute('stroke', 'white');
                    maskPath.setAttribute('stroke-width', '5');
                    maskPath.setAttribute('stroke-linecap', 'round');
                    const length = maskPath.getTotalLength();
                    maskPath.style.strokeDasharray = length;
                    maskPath.style.strokeDashoffset = length;
                    maskPath.style.transition = `stroke-dashoffset ${animationDuration / 1000}s cubic-bezier(0.6, 0, 0.4, 1) ${delay}s`;
                    mask.appendChild(maskPath);
                    defs.appendChild(mask);
                    visiblePath.setAttribute('mask', `url(#${maskId})`);
                    svg.appendChild(visiblePath);
                    requestAnimationFrame(() => maskPath.style.strokeDashoffset = 0);

                    const tracer = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    tracer.setAttribute('r', '4');
                    tracer.setAttribute('fill', strokeColor);
                    tracer.style.filter = `drop-shadow(0 0 4px ${strokeColor})`;
                    const motion = document.createElementNS("http://www.w3.org/2000/svg", "animateMotion");
                    motion.setAttribute('path', pathData);
                    motion.setAttribute('dur', `${animationDuration / 1000}s`);
                    motion.setAttribute('begin', `${delay}s`);
                    motion.setAttribute('fill', 'freeze');
                    tracer.appendChild(motion);
                    svg.appendChild(tracer);
                    
                    setTimeout(() => {
                        tracer.remove();
                        const endpoint = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        endpoint.setAttribute('cx', endCoords.x);
                        endpoint.setAttribute('cy', endCoords.y);
                        endpoint.setAttribute('r', '0');
                        endpoint.setAttribute('fill', strokeColor);
                        svg.appendChild(endpoint);
                        endpoint.classList.add('line-endpoint');
                        document.getElementById(`node-${nodeId}`)?.classList.remove('opacity-0');
                    }, (delay * 1000) + animationDuration);

                } else {
                    visiblePath.setAttribute('stroke-dasharray', '8 4');
                    svg.appendChild(visiblePath);
                }
            }
            
            function showTooltip(e, node) {
                const rect = e.currentTarget.getBoundingClientRect();
                const anchorRect = timelineAnchor.getBoundingClientRect();
                nodeTooltip.innerHTML = `<div class="flex items-center mb-2"><div class="w-8 h-8 rounded-full flex items-center justify-center text-white text-xl mr-2" style="background-color: ${node.color};">${node.icon}</div><h3 class="font-semibold text-white">${node.title}</h3></div><p class="text-gray-300 text-sm leading-relaxed">${node.description}</p>`;
                const leftPos = rect.left - anchorRect.left + (rect.width / 2);
                const topPos = rect.top - anchorRect.top;
                nodeTooltip.style.left = `${leftPos}px`;
                nodeTooltip.style.top = `${topPos}px`;
                nodeTooltip.style.transform = 'translate(-50%, calc(-100% - 12px))';
                nodeTooltip.classList.remove('hidden');
                setTimeout(() => nodeTooltip.classList.remove('opacity-0'), 10);
            }

            function hideTooltip() {
                nodeTooltip.classList.add('opacity-0');
                setTimeout(() => {
                    if (nodeTooltip.classList.contains('opacity-0')) {
                        nodeTooltip.classList.add('hidden');
                    }
                }, 300);
            }

            function renderProgressDots() {
                // Clear existing event listeners to prevent memory leaks
                progressDotsContainer.innerHTML = '';
                
                progressDotsContainer.innerHTML = timelineEvents.map((event, index) => 
                    `<div class="progress-dot w-2 h-2 rounded-full transition-all duration-500" data-index="${index}" style="background-color: ${index === currentEventIndex ? '#ef4444' : (index < currentEventIndex ? '#f87171' : '#6b7280')}; transform: ${index === currentEventIndex ? 'scale(1.5) translateZ(0)' : 'scale(1) translateZ(0)'};"></div>`
                ).join('');
                
                // Add event listeners with proper cleanup
                document.querySelectorAll('.progress-dot').forEach(dot => {
                    const clickHandler = () => {
                        const targetIndex = parseInt(dot.dataset.index);
                        if (targetIndex !== currentEventIndex && !isAnimating) {
                            goToEvent(targetIndex);
                        }
                    };
                    dot.addEventListener('click', clickHandler);
                });
            }

            async function animateYearScroll(startYear, endYear, sessionId) {
                return new Promise(resolve => {
                    if (startYear === endYear || animationSessionId !== sessionId) { resolve(); return; }
                    const totalYears = endYear - startYear;
                    const duration = Math.max(600, Math.min(2500, Math.abs(totalYears) * 100)); 
                    let startTime = null;
                    const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
                    const animationStep = (timestamp) => {
                        if (animationSessionId !== sessionId) { resolve(); return; }
                        if (!startTime) startTime = timestamp;
                        const progress = Math.min((timestamp - startTime) / duration, 1);
                        const easedProgress = easeInOutCubic(progress);
                        const frameYear = Math.floor(startYear + totalYears * easedProgress);
                        if (frameYear !== currentDisplayYear) {
                            const isEvent = timelineEvents.some(e => e.year === frameYear);
                            setOdometer(frameYear, isEvent);
                        }
                        if (progress < 1) {
                            requestAnimationFrame(animationStep);
                        } else {
                            setOdometer(endYear, true); 
                            resolve();
                        }
                    };
                    requestAnimationFrame(animationStep);
                });
            }

            // --- LOGIC & CONTROL FLOW ---
            function showEventContent(index) {
                const event = timelineEvents[index];
                if (event.type === 'network') {
                    renderNetworkView(event, () => goToEvent(index + 1));
                } else {
                    renderTypingText(event.text, () => goToEvent(index + 1));
                }
                updateUI(index);
            }
            
            async function goToEvent(targetIndex) {
                const sessionId = Date.now();
                animationSessionId = sessionId;
                clearTimeout(autoAdvanceTimeout);
                if (isAnimating && targetIndex !== currentEventIndex) {} 
                else if (isAnimating) { return; }
                if (targetIndex >= timelineEvents.length) {
                    updateUI(timelineEvents.length - 1);
                    return;
                }
                isAnimating = true;
                hideTooltip();
                let fadeOutPromise = null;
                if (contentContainer.firstElementChild) {
                    contentContainer.firstElementChild.style.opacity = 0;
                    fadeOutPromise = new Promise(res => setTimeout(res, 300));
                }
                const nextEvent = timelineEvents[targetIndex];
                const startYear = currentDisplayYear;
                const endYear = nextEvent.year;
                const scrollPromise = animateYearScroll(startYear, endYear, sessionId);
                await Promise.all([fadeOutPromise, scrollPromise]);
                if (animationSessionId !== sessionId) { isAnimating = false; return; }
                contentContainer.innerHTML = '';
                networkLinesContainer.innerHTML = '';
                currentEventIndex = targetIndex;
                showEventContent(targetIndex);
            }

            function updateUI(index) {
                renderProgressDots();
                const isLastEvent = index >= timelineEvents.length - 1;
                skipButton.classList.toggle('hidden', isLastEvent);
                restartButton.classList.toggle('hidden', !isLastEvent);
                isAnimating = false;
            }

            function start() {
                isAnimating = false;
                currentEventIndex = 0;
                setOdometer(timelineEvents[0].year, true);
                showEventContent(0);
            }

            function restart() {
                isAnimating = false;
                goToEvent(0);
            }

            function onResize() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    const currentEvent = timelineEvents[currentEventIndex];
                    if (currentEvent && currentEvent.type === 'network' && !isAnimating) {
                        redrawNetworkLines(currentEvent, false);
                    }
                }, 150);
            }

            // --- INITIALIZATION ---
            skipButton.addEventListener('click', () => goToEvent(currentEventIndex + 1));
            restartButton.addEventListener('click', restart);
            window.addEventListener('resize', onResize);
            start();
        });
    </script>
    
    <script>
        // Disable right-click and developer tools
        document.addEventListener("contextmenu", e => e.preventDefault());
        document.onkeydown = function(e) {
            if (e.keyCode == 123 || (e.ctrlKey && e.shiftKey && ['I','J','C'].includes(e.key.toUpperCase())) ) {
                return false;
            }
        }
        
        // Disable text selection and copying
        document.addEventListener('selectstart', e => e.preventDefault());
        document.addEventListener('dragstart', e => e.preventDefault());
        
        // Disable copy, cut, paste, select all
        document.addEventListener('keydown', function(e) {
            // Disable Ctrl+A (Select All)
            if (e.ctrlKey && e.keyCode === 65) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+C (Copy)
            if (e.ctrlKey && e.keyCode === 67) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+X (Cut)
            if (e.ctrlKey && e.keyCode === 88) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+V (Paste)
            if (e.ctrlKey && e.keyCode === 86) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+S (Save)
            if (e.ctrlKey && e.keyCode === 83) {
                e.preventDefault();
                return false;
            }
            // Disable Ctrl+P (Print)
            if (e.ctrlKey && e.keyCode === 80) {
                e.preventDefault();
                return false;
            }
        });
        
        // Disable text selection via CSS
        document.addEventListener('DOMContentLoaded', function() {
            const style = document.createElement('style');
            style.textContent = `
                * {
                    -webkit-user-select: none !important;
                    -moz-user-select: none !important;
                    -ms-user-select: none !important;
                    user-select: none !important;
                    -webkit-touch-callout: none !important;
                    -webkit-tap-highlight-color: transparent !important;
                }
            `;
            document.head.appendChild(style);
        });
    </script>
</body>
</html>

